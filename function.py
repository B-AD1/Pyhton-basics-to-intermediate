# -*- coding: utf-8 -*-
"""Function.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1seApEFgUK_UCfYDlIagUyKwzzowo-AuS

##Function practice
"""

#function for print

def Print(data):

"""###Decorator"""

def one():
    print("ONE")

def f(a):
    print("this is function f()")

    def t():
        print("this is inside function t()")
        a()
    return t()

f(one)

def f2(s):
    def t2():
        print("this is t2")
        s()
    return t2

def f(a):
    print("this is function f()")

    def t():
        print("this is inside function t()")
        a()
    return t

@f
@f2
def one():
    print("ONE")

one()

#doesn't work this way. There needs to be a function inaide a fucntion that calls the decorator.
def test1(func):
    print("this is inside test1")
    print(func())

@test1
def dec():
    return "this is dec function"

dec()

"""####Execution time"""

import time

a = time.time()
print("Hello")
b = time.time()
print(b-a)

a = time.time()
print("Hello")
b = time.time()
print(b-a)

a = time.time()
print("Hello")
b = time.time()
print(b-a)

l = [1,2,3,5,4,8,9]
l.index(2)

l.r

int(1.5)

int(1.9)

"""###Function for finding the number of pairs in a list."""

def pairs(n, ar):
    c = 0
    for i in ar:
        if ar.count(i) > 1:
            c = c + int(ar.count(i)/2)
            if ar.count(i)%2 == 0:
                for j in range(ar.count(i)):
                    ar.remove(i)
            else:
                for k in range((int(ar.count(i)/2))*2):
                    ar.remove(i)
    return c

# More accurate function than the before one.
 def pairs(n, ar):
    num = 0
    for i in range(0,n):
        gum = 1
        for j in range(i+1,n):
            if ar[i] == None:
                continue
            if ar[i] == ar[j] and gum ==1:
                num = num + 1
                gum = gum + 1
                ar[j] = None

    return num